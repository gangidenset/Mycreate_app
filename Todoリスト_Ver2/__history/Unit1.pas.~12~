unit Unit1;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.CheckLst,
  System.JSON, System.IOUtils, System.StrUtils, Vcl.ExtCtrls;

type
  TCheckItem = record
    Text: string;
    Checked: Boolean;
  end;

type
  TFadeItem = record
    Index: Integer;
    Alpha: Byte;  // 255 → 0 に下げていく
  end;

  TForm1 = class(TForm)
    ListBox1: TListBox;
    Edit_add: TEdit;
    Button_add: TButton;
    Button_delete: TButton;
    CheckListBox1: TCheckListBox;
    Button_path: TButton;
    Edit_search: TEdit;
    StaticText1: TStaticText;
    StaticText2: TStaticText;
    StaticText3: TStaticText;
    StaticText4: TStaticText;
    procedure Button_addClick(Sender: TObject);
    procedure ListBox1Click(Sender: TObject);
    procedure Button_deleteClick(Sender: TObject);
    procedure CheckListBox1Click(Sender: TObject);
    procedure CheckListBox1ClickCheck(Sender: TObject);
    procedure CheckListBox1DrawItem(Control: TWinControl; Index: Integer; Rect: TRect; State: TOwnerDrawState);
    procedure FormCreate(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure Button_pathClick(Sender: TObject);
    procedure Edit_searchChange(Sender: TObject);
    procedure Edit_addKeyPress(Sender: TObject; var Key: Char);
    procedure Edit_searchKeyPress(Sender: TObject; var Key: Char);
  private
    procedure SaveDate;
    procedure LoadDate;
    procedure RefreshLists; // バックアップから表示を更新
  private
    ListBoxBackup: TStringList;
    CheckListBoxBackup: TArray<TCheckItem>;
    FadingItems: array of TFadeItem;
  end;

var
  Form1: TForm1;

implementation

{$R *.dfm}

function GetIniFullPath: string;
begin
  Result := TPath.Combine(GetHomePath, 'ListBox.json');
end;

procedure TForm1.Button_pathClick(Sender: TObject);
begin
  ShowMessage('保存ファイルのパス: ' + GetIniFullPath);
end;

procedure TForm1.RefreshLists;
var
  i: Integer;
begin
  ListBox1.Items.BeginUpdate;
  try
    ListBox1.Items.Clear;
    for i := 0 to ListBoxBackup.Count - 1 do
      ListBox1.Items.Add(ListBoxBackup[i]);
  finally
    ListBox1.Items.EndUpdate;
  end;

  CheckListBox1.Items.BeginUpdate;
  try
    CheckListBox1.Items.Clear;
    for i := 0 to Length(CheckListBoxBackup) - 1 do
    begin
      CheckListBox1.Items.Add(CheckListBoxBackup[i].Text);
      CheckListBox1.Checked[i] := CheckListBoxBackup[i].Checked;
    end;
  finally
    CheckListBox1.Items.EndUpdate;
  end;
end;

procedure TForm1.Button_addClick(Sender: TObject);
var
  oldText, newText: string;
  idx: Integer;
begin
  newText := Trim(Edit_add.Text);
  if newText = '' then Exit;

  // 編集モード
  if (ListBox1.ItemIndex <> -1) or (CheckListBox1.ItemIndex <> -1) then
  begin
    // 編集対象
    if ListBox1.ItemIndex <> -1 then
      oldText := ListBox1.Items[ListBox1.ItemIndex]
    else
      oldText := CheckListBox1.Items[CheckListBox1.ItemIndex];

    // 表示リスト更新
    if ListBox1.ItemIndex <> -1 then
      ListBox1.Items[ListBox1.ItemIndex] := newText;
    if CheckListBox1.ItemIndex <> -1 then
      CheckListBox1.Items[CheckListBox1.ItemIndex] := newText;

    // バックアップ更新
    idx := ListBoxBackup.IndexOf(oldText);
    if idx <> -1 then
      ListBoxBackup[idx] := newText;

    for idx := 0 to Length(CheckListBoxBackup) - 1 do
      if CheckListBoxBackup[idx].Text = oldText then
      begin
        CheckListBoxBackup[idx].Text := newText;
        Break;
      end;
  end
  else
  begin
    // 新規追加
    ListBoxBackup.Add(newText);
    idx := Length(CheckListBoxBackup);
    SetLength(CheckListBoxBackup, idx + 1);
    CheckListBoxBackup[idx].Text := newText;
    CheckListBoxBackup[idx].Checked := False;

    // 表示リストも更新
    RefreshLists;
  end;

  Edit_add.Clear;
  ListBox1.ItemIndex := -1;
  CheckListBox1.ItemIndex := -1;
end;

procedure TForm1.Button_deleteClick(Sender: TObject);
var
  s: string;
  i: Integer;
  NewCheckList: TArray<TCheckItem>;
  j: Integer;
begin
  if ListBox1.ItemIndex > -1 then
    s := ListBox1.Items[ListBox1.ItemIndex]
  else if CheckListBox1.ItemIndex > -1 then
    s := CheckListBox1.Items[CheckListBox1.ItemIndex]
  else Exit;

  // バックアップから削除
  i := ListBoxBackup.IndexOf(s);
  if i >= 0 then
    ListBoxBackup.Delete(i);

  SetLength(NewCheckList, 0);
  for i := 0 to High(CheckListBoxBackup) do
  begin
    if CheckListBoxBackup[i].Text <> s then
    begin
      j := Length(NewCheckList);
      SetLength(NewCheckList, j + 1);
      NewCheckList[j] := CheckListBoxBackup[i];
    end;
  end;
  CheckListBoxBackup := Copy(NewCheckList, 0, Length(NewCheckList));

  // 表示リスト更新
  RefreshLists;
end;

procedure TForm1.CheckListBox1Click(Sender: TObject);
begin
  if CheckListBox1.ItemIndex > -1 then
    Edit_add.Text := CheckListBox1.Items[CheckListBox1.ItemIndex];
end;

procedure TForm1.CheckListBox1ClickCheck(Sender: TObject);
var
  txt: string;
  i: Integer;
begin
  if CheckListBox1.ItemIndex < 0 then Exit;

  txt := CheckListBox1.Items[CheckListBox1.ItemIndex];

  // Backup を Text で探す
  for i := 0 to High(CheckListBoxBackup) do
    if CheckListBoxBackup[i].Text = txt then
    begin
      CheckListBoxBackup[i].Checked := CheckListBox1.Checked[CheckListBox1.ItemIndex];
      Break;
    end;

  // ← あなたのフェードアウト処理はここに付けるのでOK
end;



procedure TForm1.CheckListBox1DrawItem(Control: TWinControl; Index: Integer; Rect: TRect; State: TOwnerDrawState);
var
  LB: TCheckListBox;
begin
  LB := Control as TCheckListBox;
  LB.Canvas.FillRect(Rect);
  if LB.Checked[Index] then
    LB.Canvas.Font.Color := clGrayText
  else
    LB.Canvas.Font.Color := clWindowText;

  LB.Canvas.TextOut(Rect.Left + 20, Rect.Top, LB.Items[Index]);
end;

procedure TForm1.Edit_addKeyPress(Sender: TObject; var Key: Char);
begin
  if Key = #13 then // Enterキー
  begin
    Key := #0;       // ビープ音防止
    Button_add.Click; // 追加処理を呼ぶ
  end;
end;

procedure TForm1.Edit_searchChange(Sender: TObject);
var
  searchText: string;
  i: Integer;
begin
  searchText := Trim(Edit_search.Text);

  // ListBox
  ListBox1.Items.BeginUpdate;
  try
    ListBox1.Items.Clear;

    if searchText = '' then
    begin
      // 検索文字が空なら全部表示
      for i := 0 to ListBoxBackup.Count - 1 do
        ListBox1.Items.Add(ListBoxBackup[i]);
    end
    else
    begin
      for i := 0 to ListBoxBackup.Count - 1 do
        if ContainsText(ListBoxBackup[i], searchText) then
          ListBox1.Items.Add(ListBoxBackup[i]);
    end;
  finally
    ListBox1.Items.EndUpdate;
  end;

  // CheckListBox
  CheckListBox1.Items.BeginUpdate;
  try
    CheckListBox1.Items.Clear;

    if searchText = '' then
    begin
      for i := 0 to Length(CheckListBoxBackup) - 1 do
      begin
        CheckListBox1.Items.Add(CheckListBoxBackup[i].Text);
        CheckListBox1.Checked[CheckListBox1.Items.Count - 1] := CheckListBoxBackup[i].Checked;
      end;
    end
    else
    begin
      for i := 0 to Length(CheckListBoxBackup) - 1 do
        if ContainsText(CheckListBoxBackup[i].Text, searchText) then
        begin
          CheckListBox1.Items.Add(CheckListBoxBackup[i].Text);
          CheckListBox1.Checked[CheckListBox1.Items.Count - 1] := CheckListBoxBackup[i].Checked;
        end;
    end;
  finally
    CheckListBox1.Items.EndUpdate;
  end;
end;


procedure TForm1.Edit_searchKeyPress(Sender: TObject; var Key: Char);
begin
  if Key = #13 then  // Enterキー
  begin
    Key := #0;       // ビープ音防止
    Edit_searchChange(Sender);  // 検索処理を呼び出す
  end;
end;

procedure TForm1.ListBox1Click(Sender: TObject);
begin
  if ListBox1.ItemIndex >= 0 then
    Edit_add.Text := ListBox1.Items[ListBox1.ItemIndex];
end;

procedure TForm1.SaveDate;
var
  JSONObject, CheckObj: TJSONObject;
  ListArray, CheckArray: TJSONArray;
  filename: string;
  i: Integer;
begin
  filename := GetIniFullPath;
  JSONObject := TJSONObject.Create;
  try
    ListArray := TJSONArray.Create;
    for i := 0 to ListBoxBackup.Count - 1 do
      ListArray.Add(ListBoxBackup[i]);
    JSONObject.AddPair('ListBox', ListArray);

    CheckArray := TJSONArray.Create;
    for i := 0 to Length(CheckListBoxBackup) - 1 do
    begin
      CheckObj := TJSONObject.Create;
      CheckObj.AddPair('Text', CheckListBoxBackup[i].Text);
      CheckObj.AddPair('Checked', TJSONBool.Create(CheckListBoxBackup[i].Checked));
      CheckArray.AddElement(CheckObj);
    end;
    JSONObject.AddPair('CheckListBox', CheckArray);

    TFile.WriteAllText(filename, JSONObject.ToString, TEncoding.UTF8);
  finally
    JSONObject.Free;
  end;
end;

procedure TForm1.LoadDate;
var
  JSONObject, CheckObj: TJSONObject;
  JSONText: string;
  ListArray, CheckArray: TJSONArray;
  filename: string;
  i: Integer;
begin
  filename := GetIniFullPath;
  if not TFile.Exists(filename) then Exit;

  JSONText := TFile.ReadAllText(filename, TEncoding.UTF8);
  JSONObject := TJSONObject.ParseJSONValue(JSONText) as TJSONObject;
  if JSONObject = nil then Exit;

  try
    ListArray := JSONObject.GetValue('ListBox') as TJSONArray;
    ListBoxBackup := TStringList.Create;
    for i := 0 to ListArray.Count - 1 do
      ListBoxBackup.Add(ListArray.Items[i].Value);

    CheckArray := JSONObject.GetValue('CheckListBox') as TJSONArray;
    SetLength(CheckListBoxBackup, CheckArray.Count);
    for i := 0 to CheckArray.Count - 1 do
    begin
      CheckObj := CheckArray.Items[i] as TJSONObject;
      CheckListBoxBackup[i].Text := CheckObj.GetValue('Text').Value;
      CheckListBoxBackup[i].Checked := (CheckObj.GetValue('Checked') as TJSONBool).AsBoolean;
    end;
  finally
    JSONObject.Free;
  end;

  RefreshLists;
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  LoadDate;
end;

procedure TForm1.FormClose(Sender: TObject; var Action: TCloseAction);
begin
  SaveDate;
  ListBoxBackup.Free;
end;

end.

