unit Unit1;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.CheckLst,
  System.JSON, System.IOUtils, System.StrUtils;

type
  TCheckItem = record
    ID: Integer;
    Text: string;
    Checked: Boolean;
  end;

  TForm1 = class(TForm)
    Edit_add: TEdit;
    Button_add: TButton;
    Button_delete: TButton;
    CheckListBox1: TCheckListBox;
    Edit_search: TEdit;
    Button_reset: TButton;
    Button_path: TButton;
    procedure FormCreate(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure Button_addClick(Sender: TObject);
    procedure Button_deleteClick(Sender: TObject);
    procedure CheckListBox1Click(Sender: TObject);
    procedure CheckListBox1ClickCheck(Sender: TObject);
    procedure Edit_searchChange(Sender: TObject);
    procedure Button_resetClick(Sender: TObject);
    procedure Button_pathClick(Sender: TObject);
  private
    ItemsBackup: TArray<TCheckItem>;
    procedure RefreshList;
    procedure SaveData;
    procedure LoadData;
  end;

var
  Form1: TForm1;

implementation

{$R *.dfm}

function GetJsonPath: string;
begin
  Result := TPath.Combine(GetHomePath, 'CheckList.json');
end;

function PrettyJSON(const S: string): string;
var
  i, indent: Integer;
  c: Char;
  inString: Boolean;
begin
  Result := '';
  indent := 0;
  inString := False;

  for i := 1 to Length(S) do
  begin
    c := S[i];

    case c of
      '"':
        begin
          Result := Result + c;
          if (i = 1) or (S[i - 1] <> '\') then
            inString := not inString;
        end;

      '{', '[':
        begin
          Result := Result + c;
          if not inString then
          begin
            Inc(indent);
            Result := Result + sLineBreak + StringOfChar(' ', indent * 2);
          end;
        end;

      '}', ']':
        begin
          if not inString then
          begin
            Dec(indent);
            Result := Result + sLineBreak + StringOfChar(' ', indent * 2) + c;
          end
          else
            Result := Result + c;
        end;

      ',':
        begin
          Result := Result + c;
          if not inString then
            Result := Result + sLineBreak + StringOfChar(' ', indent * 2);
        end;

      else
        Result := Result + c;
    end;
  end;
end;

procedure TForm1.RefreshList;
var
  i: Integer;
begin
  CheckListBox1.Items.BeginUpdate;
  try
    CheckListBox1.Items.Clear;
    for i := 0 to High(ItemsBackup) do
    begin
      CheckListBox1.Items.Add(ItemsBackup[i].Text);
      CheckListBox1.Checked[i] := ItemsBackup[i].Checked;
    end;
  finally
    CheckListBox1.Items.EndUpdate;
  end;
end;

procedure TForm1.Button_resetClick(Sender: TObject);
var
  J: TJSONObject;
begin
  J := TJSONObject.Create;
  try
    J.AddPair('items', TJSONArray.Create);
    TFile.WriteAllText(GetJsonPath, PrettyJSON(J.ToString), TEncoding.UTF8);
    ShowMessage('JSON 初期化完了！');
  finally
    J.Free;
  end;

  SetLength(ItemsBackup, 0);
  RefreshList;
end;

procedure TForm1.Button_pathClick(Sender: TObject);
begin
  ShowMessage('保存パス: ' + GetJsonPath);
end;

procedure TForm1.Button_addClick(Sender: TObject);
var
  txt: string;
  idx, id, i: Integer;
begin
  txt := Trim(Edit_add.Text);
  if txt = '' then Exit;

  // 編集モード
  if CheckListBox1.ItemIndex >= 0 then
  begin
    id := ItemsBackup[CheckListBox1.ItemIndex].ID;
    ItemsBackup[CheckListBox1.ItemIndex].Text := txt;
    RefreshList;
  end
  else
  begin
    // 新規追加
    id := TThread.GetTickCount;

    idx := Length(ItemsBackup);
    SetLength(ItemsBackup, idx + 1);

    ItemsBackup[idx].ID := id;
    ItemsBackup[idx].Text := txt;
    ItemsBackup[idx].Checked := False;

    RefreshList;
  end;

  Edit_add.Clear;
  CheckListBox1.ItemIndex := -1;
end;

procedure TForm1.Button_deleteClick(Sender: TObject);
var
  i, sel: Integer;
  tmp: TArray<TCheckItem>;
  p: Integer;
begin
  sel := CheckListBox1.ItemIndex;
  if sel < 0 then Exit;

  SetLength(tmp, 0);

  p := 0;
  for i := 0 to High(ItemsBackup) do
    if i <> sel then
    begin
      SetLength(tmp, p + 1);
      tmp[p] := ItemsBackup[i];
      Inc(p);
    end;

  ItemsBackup := tmp;
  RefreshList;
end;

procedure TForm1.CheckListBox1Click(Sender: TObject);
begin
  if CheckListBox1.ItemIndex >= 0 then
    Edit_add.Text := ItemsBackup[CheckListBox1.ItemIndex].Text;
end;

procedure TForm1.CheckListBox1ClickCheck(Sender: TObject);
var
  idx: Integer;
begin
  idx := CheckListBox1.ItemIndex;
  if idx < 0 then Exit;

  ItemsBackup[idx].Checked := CheckListBox1.Checked[idx];
end;

procedure TForm1.Edit_searchChange(Sender: TObject);
var
  s: string;
  i: Integer;
begin
  s := Trim(Edit_search.Text);

  CheckListBox1.Items.BeginUpdate;
  try
    CheckListBox1.Items.Clear;

    for i := 0 to High(ItemsBackup) do
    begin
      if (s = '') or ContainsText(ItemsBackup[i].Text, s) then
      begin
        CheckListBox1.Items.Add(ItemsBackup[i].Text);
        CheckListBox1.Checked[CheckListBox1.Items.Count - 1] := ItemsBackup[i].Checked;
      end;
    end;
  finally
    CheckListBox1.Items.EndUpdate;
  end;
end;

procedure TForm1.SaveData;
var
  Obj: TJSONObject;
  Arr: TJSONArray;
  It: TJSONObject;
  i: Integer;
begin
  Obj := TJSONObject.Create;
  try
    Arr := TJSONArray.Create;

    for i := 0 to High(ItemsBackup) do
    begin
      It := TJSONObject.Create;
      It.AddPair('ID', TJSONNumber.Create(ItemsBackup[i].ID));
      It.AddPair('Text', ItemsBackup[i].Text);
      It.AddPair('Checked', TJSONBool.Create(ItemsBackup[i].Checked));
      Arr.AddElement(It);
    end;

    Obj.AddPair('items', Arr);

    TFile.WriteAllText(GetJsonPath, PrettyJSON(Obj.ToString), TEncoding.UTF8);
  finally
    Obj.Free;
  end;
end;

procedure TForm1.LoadData;
var
  Obj, It: TJSONObject;
  Arr: TJSONArray;
  Json: string;
  i: Integer;
begin
  if not TFile.Exists(GetJsonPath) then Exit;

  Json := TFile.ReadAllText(GetJsonPath, TEncoding.UTF8);
  Obj := TJSONObject.ParseJSONValue(Json) as TJSONObject;

  if Obj = nil then Exit;

  try
    Arr := Obj.GetValue('items') as TJSONArray;

    SetLength(ItemsBackup, Arr.Count);

    for i := 0 to Arr.Count - 1 do
    begin
      It := Arr.Items[i] as TJSONObject;
      ItemsBackup[i].ID      := (It.GetValue('ID') as TJSONNumber).AsInt;
      ItemsBackup[i].Text    := It.GetValue('Text').Value;
      ItemsBackup[i].Checked := (It.GetValue('Checked') as TJSONBool).AsBoolean;
    end;

  finally
    Obj.Free;
  end;

  RefreshList;
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  LoadData;
end;

procedure TForm1.FormClose(Sender: TObject; var Action: TCloseAction);
begin
  SaveData;
end;

end.

