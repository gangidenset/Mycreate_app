unit Unit1;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.CheckLst, System.JSON,System.IOUtils;

type
  TForm1 = class(TForm)
    ListBox1: TListBox;
    Edit1: TEdit;
    Button_add: TButton;
    Button_delete: TButton;
    CheckListBox1: TCheckListBox;
    Button_path: TButton;
    procedure Button_addClick(Sender: TObject);
    procedure ListBox1Click(Sender: TObject);
    procedure Button_deleteClick(Sender: TObject);
    procedure CheckListBox1Click(Sender: TObject);
    procedure CheckListBox1ClickCheck(Sender: TObject);
    procedure CheckListBox1DrawItem(Control: TWinControl; Index: Integer;
      Rect: TRect; State: TOwnerDrawState);
    procedure FormCreate(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action:TCloseAction);
    procedure Button_pathClick(Sender: TObject);
  private
    procedure SaveDate;
    procedure LoadDate;
    { Private 宣言 }
  public
    { Public 宣言 }
  end;

var
  Form1: TForm1;

implementation

{$R *.dfm}

function GetIniFullPath: string;
begin
  Result := TPath.Combine(GetHomePath, 'ListBox.json');  // JSONファイル名に変えてね
end;

procedure TForm1.Button_pathClick(Sender: TObject);
begin
  ShowMessage('保存ファイルのパス: ' + GetIniFullPath);
end;

procedure TForm1.Button_addClick(Sender: TObject);
var
  oldText, newText: string;
  idx: Integer;
begin
  newText := Trim(Edit1.Text);
  if newText = '' then Exit;

  // --- 編集モード（リストのどちらかが選択されている） ---
  if (ListBox1.ItemIndex <> -1) or (CheckListBox1.ItemIndex <> -1) then
  begin
    // どちらを編集したか判定
    if ListBox1.ItemIndex <> -1 then
    begin
      oldText := ListBox1.Items[ListBox1.ItemIndex];
      ListBox1.Items[ListBox1.ItemIndex] := newText;
    end
    else
    begin
      oldText := CheckListBox1.Items[CheckListBox1.ItemIndex];
      CheckListBox1.Items[CheckListBox1.ItemIndex] := newText;
    end;

    // 相手側の同じ文字列も編集
    idx := CheckListBox1.Items.IndexOf(oldText);
    if idx <> -1 then
      CheckListBox1.Items[idx] := newText;

    idx := ListBox1.Items.IndexOf(oldText);
    if idx <> -1 then
      ListBox1.Items[idx] := newText;
  end
  else
  begin
    // --- 新規追加（どちらも選択されていない） ---
    ListBox1.Items.Add(newText);
    CheckListBox1.Items.Add(newText);
  end;

  // 後処理
  Edit1.Clear;
  ListBox1.ItemIndex := -1;
  CheckListBox1.ItemIndex := -1;
end;

procedure TForm1.Button_deleteClick(Sender: TObject);
var
  s: string;
  idx: integer;
begin
  if ListBox1.ItemIndex > -1 then
    s := ListBox1.Items[ListBox1.ItemIndex]
  else if checklistbox1.ItemIndex > -1 then
    s := CheckListBox1.Items[CheckListBox1.ItemIndex]
  else Exit; //どちらも選ばれていない場合

  idx := ListBox1.Items.IndexOf(s);
  if idx > -1 then
    ListBox1.Items.Delete(idx);

  idx := CheckListBox1.Items.IndexOf(s);
  if idx > -1 then
    CheckListBox1.Items.Delete(idx);
end;

procedure TForm1.CheckListBox1Click(Sender: TObject);
begin
  if CheckListBox1.ItemIndex > -1 then
    edit1.Text := CheckListBox1.Items[CheckListBox1.ItemIndex];
end;

procedure TForm1.CheckListBox1ClickCheck(Sender: TObject);
var
  i: Integer;
begin
  i := CheckListBox1.ItemIndex;
  if i < 0 then exit;

  if CheckListBox1.Checked[i] then
    CheckListBox1.Font.Color := clgraytext
  else
    checklistbox1.Font.Color := clwindowtext;
end;

procedure TForm1.CheckListBox1DrawItem(Control: TWinControl; Index: Integer;
  Rect: TRect; State: TOwnerDrawState);
var
  LB: Tchecklistbox;
begin
  LB := Control as Tchecklistbox;

  //背景の描画
  LB.Canvas.FillRect(rect);

  //完了ならグレーで描画、未完なら黒
  if LB.Checked[index] then
    LB.Canvas.Font.Color := clgraytext
  else
    LB.Canvas.Font.Color := clwindowtext;

  //テキスト描写
  LB.Canvas.TextOut(rect.left + 20, rect.Top, LB.Items[index]);
end;

procedure TForm1.ListBox1Click(Sender: TObject);
begin
  if ListBox1.ItemIndex > -1 then
    Edit1.Text := ListBox1.Items[ListBox1.Itemindex];
end;

procedure TForm1.SaveDate;
var
  JSONObject, ListObj, CheckObj: TJSONObject;
  ListArray, CheckArray: TJSONArray;
  filename: string;
  i: Integer;
begin
  //保存されるデータの保存場所と名前
  filename := TPath.Combine(GetHomePath, 'ListBox.json');
  JSONObject := TJSONObject.Create;

  try
    //ListBoxの保存
    ListArray := TJSONArray.Create;
    for i := 0 to ListBox1.Items.Count - 1 do
      ListArray.Add(ListBox1.Items[i]);
    JSONObject.AddPair('ListBox', ListArray);

    //CheckListBoxの保存＋チェック状態
    CheckArray := TJSONArray.Create;
    for i := 0 to CheckListBox1.Items.Count -1 do
    begin
      CheckObj := TJSONObject.Create;
      CheckObj.AddPair('Text', CheckListBox1.Items[i]);
      CheckObj.AddPair('Checked', TJSONBool.Create(CheckListBox1.Checked[i]));
      CheckArray.AddElement(CheckObj);
    end;
    JSONObject.AddPair('CheckListBox', CheckArray);

    //ファイルに保存
    TFile.WriteAllText(filename, JSONObject.ToString, TEncoding.UTF8);
  finally
    JSONObject.Free;
  end;
end;

procedure TForm1.LoadDate;
var
  JSONObject, CheckObj: TJSONObject;
  JSONText: string;
  ListArray, CheckArray: TJSONArray;
  filename: string;
  i: Integer;
begin
  filename := TPath.Combine(GetHomePath, 'ListBox.json');
  if not TFile.Exists(filename) then Exit;

  JSONText := TFile.ReadAllText(filename, TEncoding.UTF8);
  JSONObject := TJSONObject.ParseJSONValue(JSONText) as TJSONObject;

  if JSONObject = nil then Exit;

  try
    // ListBox
    ListArray := JSONObject.GetValue('ListBox') as TJSONArray;
    ListBox1.Items.Clear;
    for i := 0 to ListArray.Count - 1 do
      ListBox1.Items.Add(ListArray.Items[i].Value);

    // CheckListBox
    CheckArray := JSONObject.GetValue('CheckListBox') as TJSONArray;
    CheckListBox1.Items.Clear;
    for i := 0 to CheckArray.Count - 1 do
    begin
      CheckObj := CheckArray.Items[i] as TJSONObject;
      CheckListBox1.Items.Add(CheckObj.GetValue('Text').Value);
      CheckListBox1.Checked[i] := (CheckObj.GetValue('Checked') as TJSONBool).AsBoolean;
    end;
  finally
    JSONObject.Free;
  end;
end;


procedure TForm1.FormCreate(Sender: TObject);
begin
  LoadDate;
end;

procedure TForm1.FormClose(Sender: TObject; var Action:TCloseAction);
begin
  SaveDate;
end;

end.
